{"version":3,"file":"app.js","sources":["../node_modules/composi/lib/h.js","../node_modules/composi/lib/utils/getKey.js","../node_modules/composi/lib/utils/mixin.js","../node_modules/composi/lib/utils/setProp.js","../node_modules/composi/lib/utils/setPropHelpers/handleXlinkHref.js","../node_modules/composi/lib/utils/setPropHelpers/handleDangerouslySetInnerHTML.js","../node_modules/composi/lib/utils/setPropHelpers/handleClassName.js","../node_modules/composi/lib/utils/setPropHelpers/handleStyles.js","../node_modules/composi/lib/utils/removeElement.js","../node_modules/composi/lib/utils/removeChildren.js","../node_modules/composi/lib/utils/patchElement.js","../node_modules/composi/lib/utils/createElement.js","../node_modules/composi/lib/utils/updateElement.js","../node_modules/composi/lib/utils/rAF.js","../node_modules/composi/lib/utils/isObject.js","../node_modules/composi/lib/component.js","../node_modules/composi/lib/utils/isSameNode.js","../node_modules/composi/lib/patch.js","../dev/components/hero-search.js","../dev/components/hero-dashboard.js","../dev/components/hero-list.js","../dev/components/hero-detail.js","../node_modules/composi-router/index.js","../dev/components/title.js","../dev/components/menu.js","../dev/app.js","../dev/components/app.js","../dev/utils/routes.js","../dev/utils/fetch-heroes.js"],"sourcesContent":["/**\n * @description A virtual node defining a node to be created. This gets returns by the h function.\n * @typedef {Object} VNode\n * @prop {string} type The node to create, such as \"h1\", \"p\", \"div\", etc.\n * @prop {Object} [props] An object of key/value pairs defining properties and values for the node. These include properties such as \"class\", \"id\", \"disabled\", etc.\n * @prop {any[] | null} [children] An array of children belonging to the node.\n * @prop {string | number | undefined} [key] A unique key to identify a node.\n */\n/**\n * @description Hyperscript function. Enables definition of HTML/SVG using functions.\n * @param {string | Function} type The name of the HTML or SVG tag to create or a function using an HTML tag name.\n * @param {Object} [props] An object of property/value pairs.\n * @param {any[]} [children] Any child elements.\n * @returns {VNode} A virtual node describing an element.\n * @example Virtual node with string as content:\n * const title = h('h1', {class: 'main-title'}, 'This is the Titel!')\n * @example Virtual node with children:\n * const list = h(\n *   'ul',\n *   {class: 'list'},\n *   [\n *     h('li', {}, 'One'),\n *     h('li', {}, 'Two'),\n *     h('li', {}, 'Three')\n *   ]\n * )\n */\nexport function h(type, props, ...children) {\n  const nodes = []\n  const childNodes = []\n  let length = children.length\n  let key\n\n  while (length-- > 0) nodes.push(children[length])\n\n  if (props && props.key) {\n    // Assign by value:\n    key = props.key\n    // Remove duplicate from attributes:\n    delete props.key\n  }\n\n  while (nodes.length) {\n    const node = nodes.pop()\n    if (node && node.pop) {\n      for (length = node.length; length--; ) {\n        nodes.push(node[length])\n      }\n    } else if (node != null && node !== true && node !== false) {\n      childNodes.push(node)\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type(props || {}, childNodes)\n  } else {\n    return {\n      type,\n      props: props || {},\n      children: childNodes,\n      key\n    }\n  }\n}\n","/**\n * @description Function to get a node's key.\n * @param {Object} node A virtual node.\n * @returns {string | number | null} key.\n */\nexport const getKey = node => (node ? node.key : null)\n","/**\n * @description A function to merge two objects together. The properties of the second object will overwrite any matching properties in the first object.\n * @param {Object} obj1 The first object to merge.\n * @param {Object} obj2 The second object to merge.\n * @returns {Object} Returns a new object of the second object merged with the first.\n */\nexport function mixin(obj1, obj2) {\n  const result = {}\n  for (let i in obj1) {\n    result[i] = obj1[i]\n  }\n  for (let i in obj2) {\n    result[i] = obj2[i]\n  }\n  return result\n}\n","import { handleStyles } from './setPropHelpers/handleStyles'\nimport { handleClassName } from './setPropHelpers/handleClassName'\nimport { handleDangerouslySetInnerHTML } from './setPropHelpers/handleDangerouslySetInnerHTML'\nimport { handleXlinkHref } from './setPropHelpers/handleXlinkHref'\n\n/**\n * @description Function to set properties and attributes on element.\n * @param {HTMLElement} element The element to set props on.\n * @param {string} prop The property/attribute.\n * @param {string} value The value of the prop.\n * @param {string} oldValue The original value of the prop.\n * @param {boolean} isSVG Whether this is SVG or not\n * @returns {void} undefined\n */\nexport function setProp(element, prop, value, oldValue, isSVG) {\n  // Do not add these as node attributes:\n  if (\n    prop === 'key' ||\n    prop === 'onComponentDidMount' ||\n    prop === 'onComponentDidUpdate' ||\n    prop === 'onComponentWillUnmount'\n  ) {\n    return\n  } else if (prop === 'style' && typeof value !== 'string') {\n    handleStyles(element, prop, value, oldValue)\n  } else {\n    // Convert camel case props to lower case:\n    prop = prop.toLowerCase()\n\n    // Handle cases where 'className' is used:\n    prop = handleClassName(prop)\n\n    // Allow setting innerHTML:\n    handleDangerouslySetInnerHTML(element, prop, value)\n\n    if (prop in element && prop !== 'list' && !isSVG) {\n      element[prop] = value == (null || 'no') ? '' : value\n    } else if (\n      value != null &&\n      value !== 'null' &&\n      value !== 'false' &&\n      value !== 'no' &&\n      value !== 'off'\n    ) {\n      // Support SVG 'xlink:href' property:\n      if (prop === 'xlink-href') {\n        handleXlinkHref(element, prop, value)\n      } else {\n        if (value === 'true') value = ''\n        // Set prop as attribute, except dangerouslySetInnerHTML:\n        if (prop !== 'dangerouslysetinnerhtml')\n          element.setAttribute(prop, value)\n      }\n    }\n\n    if (\n      value == null ||\n      value === 'null' ||\n      value === 'undefined' ||\n      value === 'false' ||\n      value === 'no' ||\n      value === 'off'\n    ) {\n      element.removeAttribute(prop)\n    }\n  }\n}\n","/**\n * @description Enable setting xlink href value for browser that only support SVG 1.0.\n * @param {HTMLElement} element\n * @param {string} prop\n * @param {string | number | boolean | any[] | Object} value\n * @returns {void} undefined\n */\nexport function handleXlinkHref(element, prop, value) {\n  element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', value);\n  element.setAttribute('href', value);\n}\n","/**\n * @description Enable setting innerHTML as a prop.\n * @param {HTMLElement} element\n * @param {string} prop\n * @param {string | number | boolean | any[] | Object} value\n * @returns {void} undefined\n */\nexport function handleDangerouslySetInnerHTML(element, prop, value) {\n  if (prop === 'dangerouslysetinnerhtml') {\n    element.innerHTML = value;\n  }\n}\n","/**\n * @description Handle converting 'className' to 'class'.\n * @param {string} prop\n * @returns {string} string\n */\nexport function handleClassName(prop) {\n  if (prop === 'classname') {\n    prop = 'class';\n  }\n  return prop\n}\n","import { mixin } from '../mixin'\n/**\n * @description Handle styles defined as object literals.\n * @param {HTMLElement} element\n * @param {string} prop\n * @param {string | number | boolean | any[] | Object} value\n * @param {string | number | boolean | any[] | Object} oldValue\n * @returns {void} undefined\n */\nexport function handleStyles(element, prop, value, oldValue) {\n  for (let i in mixin(oldValue, value)) {\n    const style = value == null || value[i] == null ? '' : value[i];\n    if (i[0] === '-') {\n      element[prop].setProperty(i, style);\n    } else {\n      element[prop][i] = style;\n    }\n  }\n}\n","import { removeChildren } from './removeChildren'\n\n/**\n * @description Function to remove element from DOM.\n * @param {Node} parent The containing element in which the component resides.\n * @param {Node} element The parent of the element to remove.\n * @namespace {Node} node The element to remove.\n * @property {Object} node.props\n * @returns {void} undefined\n */\nexport const removeElement = (parent, element, node) => {\n  parent.removeChild(removeChildren(element, node))\n  if (node && node.props && node.props['onComponentDidUnmount']) {\n    node.props['onComponentDidUnmount'].call(\n      node.props['onComponentDidUnmount'],\n      parent\n    )\n  }\n}\n","/**\n * @description A function to remove the children of a node.\n * @param {Node} element The parent of the node whose children will be removed.\n * @namespace {Node} node The node whose children will be removed.\n * @property {Object} node.props\n * @returns {Node} element The parent of the removed nodes.\n */\nexport function removeChildren(element, node) {\n  const props = node.props\n  if (props) {\n    for (let i = 0; i < node.children.length; i++) {\n      removeChildren(element.childNodes[i], node.children[i])\n    }\n  }\n  return element\n}\n","import { getKey } from './getKey'\nimport { createElement } from './createElement'\nimport { updateElement } from './updateElement'\nimport { removeElement } from './removeElement'\n\n/**\n * @description A function to diff and patch a DOM node with a virtual node.\n * @param {Node} parent The parent node of the elment being patched.\n * @param {Node} element The element being patched.\n * @param {Object} oldNode A virtual dom node from the previous patch.\n * @param {Object} node The current virtual dom node.\n * @param {boolean} [isSVG] Whether we are dealing with an SVG element or not.\n * @returns {Node} element The patched element.\n */\nexport function patchElement(parent, element, oldNode, node, isSVG) {\n  // Short circuit patch if VNodes are identical\n  if (node === oldNode) {\n    return\n  } else if (oldNode == null || oldNode.type !== node.type) {\n    const newElement = createElement(node, isSVG)\n    if (parent) {\n      parent.insertBefore(newElement, element)\n      if (oldNode != null) {\n        removeElement(parent, element, oldNode)\n      }\n    }\n    element = newElement\n  } else if (oldNode.type == null) {\n    element.nodeValue = node\n  } else {\n    updateElement(\n      element,\n      oldNode.props,\n      node.props,\n      (isSVG = isSVG || node.type === 'svg')\n    )\n\n    const oldKeyed = {}\n    const newKeyed = {}\n    const oldElements = []\n    const oldChildren = oldNode.children\n    const children = node.children\n\n    for (let i = 0; i < oldChildren.length; i++) {\n      oldElements[i] = element.childNodes[i]\n\n      const oldKey = getKey(oldChildren[i])\n      if (oldKey != null) {\n        oldKeyed[oldKey] = [oldElements[i], oldChildren[i]]\n      }\n    }\n\n    let i = 0\n    let k = 0\n\n    while (k < children.length) {\n      let oldKey = getKey(oldChildren[i])\n      let newKey = getKey(children[k])\n\n      if (newKeyed[oldKey]) {\n        i++\n        continue\n      }\n\n      if (newKey != null && newKey === getKey(oldChildren[i + 1])) {\n        if (oldKey == null) {\n          removeElement(element, oldElements[i], oldChildren[i])\n        }\n        i++\n        continue\n      }\n\n      if (newKey == null) {\n        if (oldKey == null) {\n          patchElement(\n            element,\n            oldElements[i],\n            oldChildren[i],\n            children[k],\n            isSVG\n          )\n          k++\n        }\n        i++\n      } else {\n        const keyedNode = oldKeyed[newKey] || []\n\n        if (oldKey === newKey) {\n          patchElement(element, keyedNode[0], keyedNode[1], children[k], isSVG)\n          i++\n        } else if (keyedNode[0]) {\n          patchElement(\n            element,\n            element.insertBefore(keyedNode[0], oldElements[i]),\n            keyedNode[1],\n            children[k],\n            isSVG\n          )\n        } else {\n          patchElement(element, oldElements[i], null, children[k], isSVG)\n        }\n\n        newKeyed[newKey] = children[k]\n        k++\n      }\n    }\n\n    while (i < oldChildren.length) {\n      if (getKey(oldChildren[i]) == null) {\n        removeElement(element, oldElements[i], oldChildren[i])\n      }\n      i++\n    }\n\n    for (let i in oldKeyed) {\n      if (!newKeyed[i]) {\n        removeElement(element, oldKeyed[i][0], oldKeyed[i][1])\n      }\n    }\n  }\n  return element\n}\n","import { setProp } from './setProp'\n\n/**\n * @description Function to convert hyperscript/JSX into DOM nodes.\n * @param {Object | string} node A node to create. This may be a hyperscript function or a JSX tag which gets converted to hyperscript during transpilation.\n * @param {boolean} [isSVG] Whether the node is SVG or not.\n * @returns {Node} An element created from a virtual dom object.\n */\nexport function createElement(node, isSVG) {\n  let element\n  if (typeof node === 'number') node = node.toString()\n  if (typeof node === 'string') {\n    element = document.createTextNode(node)\n  } else if ((isSVG = isSVG || node.type === 'svg')) {\n    element = document.createElementNS('http://www.w3.org/2000/svg', node.type)\n  } else {\n    element = document.createElement(node.type)\n  }\n  /**\n   * @property {Object} node.props A virtual node stored on the node.\n   */\n  const props = node.props\n  if (props) {\n    for (let i = 0; i < node.children.length; i++) {\n      element.appendChild(createElement(node.children[i], isSVG))\n    }\n\n    for (let prop in props) {\n      setProp(element, prop, props[prop], null, isSVG)\n    }\n  }\n\n  return element\n}\n","import { mixin } from './mixin'\nimport { setProp } from './setProp'\n\n/**\n * @description A function to update an element based on a virtual dom node.\n * @namespace {Node | HTMLElement} element The element to update\n * @param {Object} oldProps The original props used to create the element.\n * @param {Object} props New props generated by the virtual dom.\n * @param {boolean} isSVG Whether we are dealing with SVG or not.\n * @returns {void} undefined\n */\nexport function updateElement(element, oldProps, props, isSVG) {\n  for (let prop in mixin(oldProps, props)) {\n    if (\n      props[prop] !==\n      (prop === 'value' || prop === 'checked' ? element[prop] : oldProps[prop])\n    ) {\n      setProp(element, prop, props[prop], oldProps[prop], isSVG)\n    }\n  }\n  // Handle lifecycle hook:\n  if (element.mounted && props && props['onComponentDidUpdate']) {\n    props['onComponentDidUpdate'].call(\n      props['onComponentDidUpdate'],\n      oldProps,\n      props,\n      element\n    )\n  }\n}\n","/**\n * @description A cross-browser normalization/polyfill for requestAnimationFrame.\n * @param {Function} cb A callback to execute.\n * @returns {any} The result of the callback.\n */\nexport const rAF =\n  (window && window.requestAnimationFrame) ||\n  (window && window['msRequestAnimationFrame']) ||\n  function(cb) {\n    return setTimeout(cb, 16)\n  }\n","/**\n * @description A function to test where something is an object literal or not. Used by Component setState.\n * @param {Object} obj An object literal to test.\n * @returns boolean\n */\nexport function isObject(obj) {\n  if (Array.isArray(obj)) return false\n  else if (typeof obj === 'object') return true\n  else return false\n}\n","import { patch } from './patch'\nimport { mixin } from './utils/mixin'\nimport { rAF } from './utils/rAF'\nimport { isSameNode } from './utils/isSameNode'\nimport { isObject } from './utils/isObject'\n\n/**\n * @description This is a Time Object used as a key to create a pseudo-private property in the Component class for holding state.\n * @type {Object} dataStore A Date object to use as pseudo-private key to store the component's state.\n */\nconst dataStore = new Date().getTime()\n\n/**\n * @description Component can be instantiated with the new keyword, or extended to create a custom version of the class.\n * @class Class to create a component.\n * @example New instance of Component class:\n * const title = new Component({\n *   container: 'header',\n *   state: 'World',\n *   render: message => <h1>Hello, {message}!</h1>\n * })\n * @example Extending Component class:\n * class UserList extends Component {\n *   constructor(props) {\n *     super(props)\n *     this.state = users\n *     this.container = 'section'\n *   }\n *   render(users) {\n *     return (\n *      <ul class='user-list'>\n *        {\n *          users.map(user => <li>{user.name}</li>)\n *        }\n *      </ul>\n *     )\n *   }\n * }\n */\nexport class Component {\n  /**\n   * @constructor\n   * @description Constructor for Component class.\n   * @property {state} [props.state] The state object of the component. This can be of type boolean, string, number, object or array.\n   * @property {string} selector A CSS selector describing the DOM container in which to render the component.\n   * @property {HTMLElement} container The DOM node in which the component is rendered.\n   * @property {boolean} componentShouldUpdate A flag to determine whether a component can render or not. Setting this to false allows you to maipulate a component's state without triggering and automatic render. After setting to true, you may need to execute `update()` on a component instance to force render it.\n   * @property {boolean} mounted A boolean flag that tracks whether a component has been mounted in the DOM or not. This is used internally by Composi, do not touch!\n   * @property {HTMLElement} element The root or base element of a component's DOM tree. You can use it to register events or as the basis of a component-specific DOM query.\n   * @property {Function} componentWillMount A callback that is called before a component is mounted in the DOM.\n   * @property {Function} componentDidMount A callback that is called after a component is mounted in the DOM. Use this to register events, query the component DOM, etc.\n   * @property {Function} componentWillUpdate A callback that is called before a component is updated. This is not called the first time a component is rendered.\n   * @property {Function} componentDidUpdate A callback that is called after a component is updated. This is not called the first time a component is rendered.\n   * @property {Function} componentWillUnmount A callback that is called before a component is unmounted from the DOM. Use this for any environmental cleanup.\n   * @property {Function} render A method that returns nodes to render to the DOM.¸\n   * @property {Function} update A method that renders the component template with provided data to the DOM. Data may be provided directly as the primary argument, or it can be derived from the component's state. Data provided as an argument will override use of component state.\n   * @property {Function} unmount A method to unmount a component from the DOM. This deletes the DOM tree structure starting from the component's base element, and sets the component instance properties to null.\n   * @constructs Component\n   */\n  constructor(props) {\n    if (!props) props = {}\n    /**\n     * @property {Object} props An object literal of options passed to the class constructor during initialization.\n     */\n    this.props = props\n    /**\n     * @property {string | HTMLElement} container The HTML element in which the component gets rendered. This can be a CSS selector describing the container or a DOM node reference.\n     */\n    this.selector = props.container || 'body'\n\n    if (props.render) {\n      /**\n       * @property {Function} render A method to convert markup into DOM nodes to inject in the document. The method itself gets provided at init time by a function provided by the user as an argument, or in the case of extending, a method defined directly on the class extension.\n       */\n      this.render = props.render\n    }\n\n    if (props.state) {\n      /**\n       * @property {boolean | number | string | Object | any[]}\n       */\n      this.state = props.state\n    }\n\n    if (this.selector) {\n      /**\n       * @property {HTMLElement} container The HTML element in which the component gets rendered.\n       */\n      this.container = document.querySelector(this.selector)\n    }\n\n    /**\n     * @property {boolean} componentShouldUpdate Determines whether a component should update. Set `componentShouldUpdate` to `false`, make changes, then set  `componentShouldUpdate` to `true` and update component with `update` method.\n     */\n    this.componentShouldUpdate = true\n\n    /**\n     * @property {boolean} mounted Indicates whether a component is mounted in the DOM or not. This is used internally, so do not change!\n     */\n    this.mounted = false\n\n    /**\n     * @property {HTMLElement}\n     */\n    this.element\n\n    if (props.componentWillMount)\n      /**\n       * @property {Function} componentWillMount A method to execute a callback before the component mounts. The callback gets a reference to the component instance as its argument.\n       * @returns {void} undefined\n       */\n      this.componentWillMount = props.componentWillMount\n\n    if (props.componentDidMount)\n      /**\n       * @property {Function} componentDidMount  A method to execute a callback after the component mounts. The callback gets a reference to the component instance as its argument.\n       * @returns {void} undefined\n       */\n      this.componentDidMount = props.componentDidMount\n\n    if (props.componentWillUpdate)\n      /**\n       * @property {Function} componentWillUpdate A method to execute a callback before the component updates. The callback gets a reference to the component instance as its argument.\n       * @returns {void} undefined\n       */\n      this.componentWillUpdate = props.componentWillUpdate\n\n    if (props.componentDidUpdate)\n      /**\n       * @property {Function} componentDidUpdate -A method to execute a callback after the component updates. The callback gets a reference to the component instance as its argument.\n       * @returns {void} undefined\n       */\n      this.componentDidUpdate = props.componentDidUpdate\n\n    if (props.componentWillUnmount)\n      /**\n       * @property {Function} componentWillUnmount A method to execute a callback before the component unmounts. The callback gets a reference to the component instance as its argument.\n       * @returns {void} undefined\n       */\n      this.componentWillUnmount = props.componentWillUnmount\n  }\n\n  /**\n   * @method A method to execute a callback before the component mounts.\n   * @returns {void} undefined\n   */\n  componentWillMount(cb) {\n    return cb\n  }\n  /**\n   * @method A method to execute a callback after the component mounts.\n   * @returns {void} undefined\n   */\n  componentDidMount(cb) {\n    return cb\n  }\n  /**\n   * @method A method to execute a callback before the component updates.\n   * @returns {void} undefined\n   */\n  componentWillUpdate(cb) {\n    return cb\n  }\n  /**\n   * @method A method to execute a callback after the component updates.\n   * @returns {void} undefined\n   */\n  componentDidUpdate(cb) {\n    return cb\n  }\n  /**\n   * @method A method to execute a callback after the component updates.\n   * @returns {void} undefined\n   */\n  componentWillUnmount(cb) {\n    return cb\n  }\n  /**\n   * @method A method to create a virtual node from data and markup. The returned virtual node will get converted into a node that gets injected in the DOM.\n   * @param {*} data\n   */\n  render(data) {\n    return data\n  }\n  /** End of type stubs */\n\n  /**\n   * @method This is getter to access the component's state using the pseudo-private key dataStore.\n   * @returns {boolean | number | string | Object | any[]} The component's state\n   */\n  get state() {\n    return this[dataStore]\n  }\n\n  /**\n   * @method This is a setter to define the component's state. It uses the dataStore object as a pseudo-private key. It uses requestAnimationFrame to throttle component updates to avoid layout thrashing.\n   * @param {string | number | boolean | Object | any[]} data Data to set as component state.\n   * @returns {void} undefined\n   */\n  set state(data) {\n    this[dataStore] = data\n    rAF(() => this.update())\n  }\n\n  /**\n   * @method Method to set a component's state. This accepts simple types or Objects. If updating an array, you can pass in the data and the position (number) in the array to update. Optionally you can pass a callback, which receives the state as its argument. You need to return the state changes in order to update the component's state.\n   * @example\n   * this.setState(true)\n   * this.setState(0)\n   * this.setState({name: 'Joe'})\n   * this.setState([1,2,3])\n   * this.setState(prevState => prevState + 1)\n   * @param {string | number | boolean | Object | any[] | Function} data The data to set. This canIf a callback is passed as the argument to execute, it gets passed the previous state as its argument. You need to make sure the callback returns the final state or the component will not update.\n   * @returns {void} undefined\n   */\n  setState(data) {\n    if (typeof data === 'function') {\n      const state = data.call(this, this.state)\n      if (state) this.state = state\n    } else if (isObject(this.state) && isObject(data)) {\n      const state = this.state\n      this.state = mixin(state, data)\n    } else {\n      this.state = data\n    }\n  }\n\n  /**\n   * @method Function to render component after data changes.\n   * If data is passed as argument, it will be used.\n   * Otherwise state will be used.\n   * @param {boolean | number | string | Object | any[]} [data] By default, data will be the component's current state, otherwise, if data is provided as an argument, that will be used, overriding the state.\n   * @returns {void} undefined\n   */\n  update(data) {\n    if (!this.render) return\n\n    // If componentShouldUpdate is set to false,\n    // render one time only.\n    // All other updates will be ignored.\n    if (!this.componentShouldUpdate && this.mounted) return\n\n    // If data is 0 or non-boolean, use,\n    // else use component state.\n    let __data = this.state\n    if (data !== true && data) __data = data\n\n    if (this.container && typeof this.container === 'string') {\n      this.selector = this.container\n      this.container = document.querySelector(this.container)\n    }\n\n    // Create virtual dom and check if component id\n    // already exists in document.\n    /**\n     * @type {Object | null}\n     */\n    const vdom = this.render(__data)\n    let elem\n    if (vdom && vdom.props && vdom.props.id && this.container) {\n      elem = this.container && this.container.querySelector(`#${vdom.props.id}`)\n    }\n\n    // If component element id already exists in DOM,\n    // remove it before rendering the component.\n    if (elem && !this.mounted) {\n      elem.parentNode.removeChild(elem)\n    }\n\n    // Capture old node to use with isSameNode if component has already mounted:\n    const __oldNode = this.element && this.element.node\n\n    // Short circuit update if VNodes are identical:\n    if (isSameNode(__oldNode, __data, this)) return\n\n    /**\n     * @property {HTMLElement} element The base element of the rendered component. You can use this as the base for comopnent instance specific DOM queries or event registration.\n     */\n    this.element = patch(this.render(__data), this.element)\n    if (!this.mounted) {\n      this.componentWillMount && this.componentWillMount(this)\n      if (!this.container || this.container.nodeType !== 1) {\n        console.error(\n          'The container for a class component is not a valid DOM node. Check the selector provided for the class to make sure it is a valid CSS selector and that the container exists in the DOM. You might be targeting a nonexistent node.'\n        )\n      }\n      this.container.appendChild(this.element)\n      this.mounted = true\n      this.componentDidMount && this.componentDidMount(this)\n      return\n    }\n\n    this.componentWillUpdate && this.componentWillUpdate(this)\n    this.componentDidUpdate && this.componentDidUpdate(this)\n  }\n\n  /**\n   * @method Method to destroy a component.\n   * First unbind events.\n   * Then remove component element from DOM.\n   * Also null out component properties.\n   * @returns {void} undefined\n   */\n  unmount() {\n    const eventWhitelist = [\n      'change',\n      'click',\n      'dblclick',\n      'input',\n      'keydown',\n      'keypress',\n      'keyup',\n      'mousedown',\n      'mouseleave',\n      'mouseout',\n      'mouseover',\n      'mouseup',\n      'pointercancel',\n      'pointerdown',\n      'pointermove',\n      'pointerup',\n      'select',\n      'submit',\n      'touchcancel',\n      'touchend',\n      'touchmove',\n      'touchstart'\n    ]\n    if (!this.element) return\n    this.componentWillUnmount && this.componentWillUnmount(this)\n    eventWhitelist.map(event => {\n      this.element.removeEventListener(event, this)\n    })\n    this.container.removeChild(this.element)\n    this.container = undefined\n    for (let key in this) {\n      delete this[key]\n    }\n    delete this.state\n    this.update = undefined\n    this.unmount = undefined\n  }\n}\n","/**\n * @description A function to test whether the data provided for updating a component creates a new virtual node or not.\n * @param {Object} oldNode The previous virtual node of a component.\n * @param {*} data Data to be used when rendering a new virtual node for a component.\n * @param {Object} component A reference to the component being used.\n */\nexport function isSameNode(oldNode, data, component) {\n  if (\n    component &&\n    JSON.stringify(oldNode) === JSON.stringify(component.render(data))\n  ) {\n    return true\n  }\n  return false\n}\n","import { patchElement } from './utils/patchElement'\n\n/**\n * @description A function to patch a virtual node against a DOM element, updating it in the most efficient manner possible.\n * @param {Object} node A virtual node. This may be a JSX tag or a hyperscript function.\n * @param {Node} [element] The element to patch.\n * @returns {Node} The updated element.\n */\nexport function patch(node, element) {\n  if (element) {\n    patchElement(element.parentNode, element, element && element['node'], node)\n  } else {\n    element = patchElement(null, null, null, node)\n  }\n\n  element['node'] = node\n\n  return element\n}\n","import {h} from 'composi'\n\nexport default function HeroSearch({search, searchResults, blurSearchInput}) {\n  return (\n    <div id=\"search-component\">\n      <h4>Hero Search</h4>\n\n      <input id=\"search-box\" onkeyup={(e)=> search(e)} onblur={() => blurSearchInput()} />\n\n      {\n        searchResults.length > 0 && (\n          <ul class=\"search-result\">\n            {\n              searchResults.map(hero => (\n                <li>\n                  <a href={`#/detail/${hero.id}`}>{hero.name}</a>\n                </li>\n              ))\n            }\n          </ul>\n        )\n      }\n    </div>\n  )\n}\n","import {h, Component} from 'composi'\nimport HeroSearch from './hero-search'\n\nexport default function HeroDashboard({heroes, search, searchResults, blurSearchInput}) {\n  const selectHeroes = heroes.slice(1, 5)\n  return (\n    <div class='dashboard'>\n      <h3>Top Heroes</h3>\n      <div class=\"grid grid-pad\">\n        {\n          selectHeroes.map(hero => (\n            <a class=\"col-1-4\" href={`#/detail/${hero.id}`}>\n              <div class=\"module hero\">\n                <h4>{hero.name}</h4>\n              </div>\n            </a>\n          ))\n        }\n      </div>\n      <HeroSearch \n        search={search}\n        searchResults={searchResults}\n        blurSearchInput={blurSearchInput} />\n    </div>\n  )\n}\n","import {h, Component} from 'composi'\n\nexport default function HeroList({heroes, deleteItem, addHero}) {\n\n  return (\n    <div>\n      <p class='form--add-hero'>\n        <label htmlFor=\"add-hero\">Hero name: </label>\n        <input id='add-hero' type=\"text\"/>\n        <button onclick={addHero}>Add</button>\n      </p>\n      <ul class=\"heroes\">\n        {\n          heroes.map(hero => (\n            <li>\n              <a href={`#/detail/${hero.id}`}>\n                <span class=\"badge\">{hero.id}</span> \n                <span class='hero-link'>{hero.name}</span>\n              </a>\n              <button data-id={hero.id} class=\"delete\" title=\"delete hero\"\n              onclick={(e) => deleteItem(e)}>x</button>\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  )\n}\n","import {h, Component} from 'composi'\n\nexport default function HeroDetail({hero, onHeroNameChange, resetName, saveName}) {\n  return (\n    <div id='hero-detail'>\n      <h2>{hero.name} details!</h2>\n      <div><label>id:</label> {hero.id}</div>\n      <div>\n        <label for='update-name'>name: </label>\n        <input id='update-name' placeholder={hero.name} oninput={(e) => onHeroNameChange(e)} />\n      </div>\n      <p class='hero-detail--buttons'>\n        <button onclick={resetName}>Reset</button>\n        <button onclick={saveName}>Save</button>\n      </p>\n    </div>\n  )\n}\n","/**\n  * Route type\n  * @constructor\n  *\n  * Creates a Route object for general use\n  * \n  * @param {String} path\n  * @param {type}   name\n  */\nfunction Router(w, isModule) {\n  let routes = []\n  let map = {}\n  let reference = 'router'\n  let oldReference = window[reference]\n  let oldUrl\n\n  class Route {\n    constructor(path, name) {\n      this.name = name\n      this.path = path\n      this.keys = []\n      this.fns = []\n      this.params = {}\n      this.pathToRegexp = (path, keys, sensitive, strict) => {\n        if (path instanceof RegExp) return path\n        if (path instanceof Array) path = '(' + path.join('|') + ')'\n        path = path\n          .concat(strict ? '' : '/?')\n          .replace(/\\/\\(/g, '(?:/')\n          .replace(/\\+/g, '__plus__')\n          .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n            keys.push({ name: key, optional: !! optional })\n            slash = slash || ''\n            return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')' + (optional || '')\n          })\n          .replace(/([/.])/g, '\\\\$1')\n          .replace(/__plus__/g, '(.+)')\n          .replace(/\\*/g, '(.*)')\n        return new RegExp('^' + path + '$', sensitive ? '' : 'i')\n      }\n      this.regex = this.pathToRegexp(this.path, this.keys, false, false)\n    }\n\n    /**\n     * Adds a handler for \"this\" route\n     * \n     * @param {Function} fn\n     */\n    addHandler(fn) {\n      this.fns.push(fn)\n    }\n\n    /**\n     * Removes specific handler for this route\n     * \n     * @param  {Function} fn\n     * @return {void}\n     */\n    removeHandler(fn) {\n      for (let i = 0, c = this.fns.length; i < c; i++) {\n        let f = this.fns[i]\n        if (fn == f) {\n          this.fns.splice(i, 1)\n          return\n        }\n      }\n    }\n\n    /**\n     * Executes this route with specified params\n     * \n     * @param  {Object} params\n     * @return {void}\n     */\n    run(params) {\n      for (let i = 0, c = this.fns.length; i < c; i++) {\n        if (this.fns[i].apply(this, params) === false)\n          return false\n      }\n      return true\n    }\n\n    /**\n     * Tests a path of this route and runs if it's successed\n     * @param  {String} path\n     * @param  {Object} params\n     * @return {Bool}\n     */\n    match(path, params){\n      let m = this.regex.exec(path)\n      if (!m) return false\n      for (let i = 1, len = m.length; i < len; ++i) {\n        let key = this.keys[i - 1]\n        let val = ('string' == typeof m[i]) ? decodeURIComponent(m[i]) : m[i]\n        if (key) {\n          this.params[key.name] = val\n        }\n        params.push(val)\n      }\n      return true\n    }\n  }\n\n  /**\n   * This is the main constructor for router object\n   * Creates a route or navigates it if second parameter is empty\n   * \n   * @param  {String}    path       name of to route to register or to navigate\n   * @param  {Function}  fn         callback founction for this route\n   * @returns {void}\n   */\n  const router = (path, fn) =>  {\n    let addHandler = (path, fn) => {\n      let s = path.split(' ')\n      let name = (s.length == 2) ? s[0] : null\n      path = (s.length == 2) ? s[1] : s[0]\n\n      if (!map[path]) {\n        map[path] = new Route(path, name)\n        routes.push(map[path])\n      }\n      map[path].addHandler(fn)\n    }\n    if (typeof fn == 'function') {\n      addHandler(path, fn)\n      router.reload()\n    } else if (typeof path == 'object') {\n      for (let p in path) {\n        addHandler(p, path[p])\n      }\n      router.reload()\n    } else if (typeof fn === 'undefined') {\n      router.navigate(path)\n    }\n  }\n\n  /**\n   * Removes specified handlerfor specified path\n   * Remeber that: one path can have multiple handlers/callbacks functions\n   * you should specify exact object that refers handler\n   * \n   * @param  {String}   path       target path to remove\n   * @param  {Function} fn         handler function\n   * @return {void}\n   */\n  router.remove = (path, fn) => {\n    let route = map[path]\n    if (!route)\n      return\n    route.removeHandler(fn)\n  }\n\n  /**\n   * Removes all handlers and routes\n   * \n   * @return {void}\n   */\n  router.removeAll = () => {\n    map = {}\n    routes = []\n    oldUrl = ''\n  }\n\n  /**\n   * Navigates current route to desired one\n   * \n   * @param  {String} path        target path to navigate\n   * @param  {Object} options     options for this navigate\n   * @return {void}\n   */\n  router.navigate = (path, options) => {\n    options = options || {}\n    let silent = options.silent || false\n\n    if (silent) {\n      removeListener()\n    }\n    setTimeout(() => {\n      window.location.hash = path\n\n      if (silent) {\n        setTimeout(() => addListener(), 1)\n      }\n\n    }, 1)\n  }\n\n  /**\n   * Creates a reference for prevent conflicts\n   * @return {Object}\n   */\n  router.noConflict = () => {\n    w[reference] = oldReference\n    return router\n  }\n\n  /**\n   * Reload the page without changing the hash\n   * @param {String} path \n   */\n  router.load = (path) => {\n    map[path].run()\n  }\n\n  /**\n   * Get the location hash\n   * @return {String}\n   */\n  const getHash = () => {\n    return window.location.hash.substring(1)\n  }\n\n  /**\n   * Checks to see if a hash matches a route\n   * @param {String} hash \n   * @param {String} route \n   */\n  const checkRoute = (hash, route) => {\n    let params = []\n    if (route.match(hash, params)) {\n      return (route.run(params) !== false ? 1 : 0)\n    }\n    return -1\n  }\n\n  /**\n   * Check whether location hash has changes\n   */\n  const hashChanged = router.reload = () => {\n    let hash = getHash()\n    for (let i = 0, c = routes.length; i < c; i++) {\n      let route = routes[i]\n      let state = checkRoute(hash, route)\n      if (state === 1) {\n        // route processed:\n        oldUrl = hash\n        break\n      } else if (state === 0){\n        // route rejected:\n        router.navigate(oldUrl, { silent:true })\n        break\n      }\n    }\n  }\n\n  /**\n   * Add haschange event listener\n   */\n  const addListener = () => {\n    if (w.addEventListener) {\n      w.addEventListener('hashchange', hashChanged, false)\n    } else {\n      w.attachEvent('onhashchange', hashChanged)\n    }\n  }\n\n  /**\n   * Remove hashchange event listener\n   */\n  const removeListener = () => {\n    if (w.removeEventListener) {\n      w.removeEventListener('hashchange', hashChanged)\n    } else {\n      w.detachEvent('onhashchange', hashChanged)\n    }\n  }\n\n  addListener()\n  oldUrl = getHash()\n\n  if (isModule){\n    return router\n  } else {\n    w[reference] = router\n  }\n\n}\n\nif (typeof module == 'undefined') {\n  Router(window)\n} else {\n  module.exports = Router(window, true)\n  module.exports.default = module.exports\n}\n","import {h, Component} from 'composi'\n\nexport default new Component ({\n  container: 'header',\n  state: 'Tour of Heroes',\n  render: (message) => <h1><a href=\"/\">{message}</a></h1>\n})\n","import {h, Component} from 'composi'\n\nexport default new Component({\n  container: 'section',\n  state: true,\n  render: (data) => {\n    return (\n      <nav>\n        <ul>\n          <li><a href=\"#/dashboard\">Dashboard</a></li>\n          <li><a href=\"#/heroes\">Heroes</a></li>\n        </ul>\n      </nav>\n    )\n  }\n})\n","import {h, render, Component} from 'composi'\nimport title from './components/title'\nimport menu from './components/menu'\nimport App from './components/app'\n\nconst app = new App()\n","import {h, render, Component} from 'composi'\nimport HeroDashboard from './hero-dashboard'\nimport HeroList from './hero-list'\nimport HeroDetail from './hero-detail'\nimport setupRoutes from '../utils/routes'\nimport fetchHeroes from '../utils/fetch-heroes'\n\nexport default class App extends Component {\n  constructor(props) {\n    super(props) \n    this.container = 'section'\n    this.state = {\n      activeComponent: 'dashboard',\n      heroes: [],\n      selectedHero: '',\n      searchResults: []\n    }\n  }\n\n  render(state) {\n\n    return (\n      <div class=\"app-root\">\n        {\n          state.activeComponent === 'dashboard' && \n            <HeroDashboard \n              heroes={this.state.heroes}\n              search={this.search.bind(this)}\n              searchResults={this.state.searchResults} \n              blurSearchInput={this.blurSearchInput.bind(this)} />\n        }\n        {\n          state.activeComponent === 'heroes' && \n            <HeroList \n              heroes={this.state.heroes} \n              deleteItem={this.deleteItem.bind(this)} \n              addHero={this.addHero.bind(this)} />\n        }\n        {\n          state.activeComponent === 'detail' && \n            <HeroDetail \n              hero={this.state.selectedHero} \n              deleteItem={this.deleteItem}\n              onHeroNameChange={this.onHeroNameChange.bind(this)} \n              resetName={this.resetName.bind(this)} \n              saveName={this.saveName.bind(this)} />\n        }\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    // Fetch data for heroes:\n    fetchHeroes()\n      .then(heroes => {\n        this.setState({heroes})\n      })\n    // Setup routes:\n    setupRoutes(this)\n  }\n\n  addHero(e) {\n    const input = e.target.parentNode.querySelector('#add-hero')\n    const value = input.value\n    if (value) {\n      const lastId = this.state.heroes[this.state.heroes.length -1].id\n      const newHero = {id: String(parseInt(lastId) + 1), name: value}\n      const heroes = this.state.heroes\n      heroes.push(newHero)\n      this.setState({heroes})\n      input.value = ''\n    }\n  }\n\n  deleteItem(e) {\n    const id = e.target.dataset.id\n    const heroes = this.state.heroes\n    const position = heroes.findIndex(hero => id == hero.id)\n    heroes.splice(position, 1)\n    this.setState({heroes})\n  }\n\n  onHeroNameChange(e) {\n    const value = e.target.value\n    if (value) {\n      const selectedHero = this.state.selectedHero\n      selectedHero.name = value\n      this.setState({selectedHero})\n    }\n  }\n\n  resetName(e) {\n    const selectedHero = this.state.selectedHero\n    selectedHero.name = selectedHero.originalName\n    this.setState({selectedHero})\n  }\n\n  saveName(e) {\n    window.location.hash = '#/heroes'\n  }\n\n  search(e) {\n    const input = e.target\n    const value = input.value\n    const heroes = this.state.heroes\n    const searchResults = heroes.filter(hero => {\n      const name = hero.name.toLowerCase()\n      return name.match(value.toLowerCase())\n    })\n    this.setState({searchResults: searchResults})\n  }\n\n  blurSearchInput(e) {\n    const searchResults = this.state.searchResults\n    setTimeout(() => {\n      this.setState({searchResults: []})\n    }, 250)\n  }\n}","import {Router} from 'composi-router'\n\nexport default function(app) {\n  router({\n    '/': function() {\n      app.setState({activeComponent: 'dashboard'})\n    },\n\n    '/dashboard': function() {\n      app.setState({activeComponent: 'dashboard'})\n    },\n\n    '/heroes': function() {\n      app.setState({activeComponent: 'heroes'})\n    },\n\n    '/detail/:id': function(id) {\n      const state = app.state\n      const position = state.heroes.findIndex(person => person.id === id)\n      const hero = state.heroes[position]\n      try {\n        hero.originalName = hero.name\n        app.setState({activeComponent: 'detail', selectedHero: hero})\n      } catch(err) {}\n    }\n  })\n}\n","// Fetch mock heroes:\nexport default function fetchHeroes() {\n  return fetch('/dev/data/mock-heroes.js')\n  .then(function(response) {\n    return response.json()\n  })\n}\n"],"names":["h","type","props","nodes","childNodes","children","length","key","push","node","pop","getKey","mixin","obj1","obj2","result","i","setProp","element","prop","value","oldValue","isSVG","style","setProperty","toLowerCase","innerHTML","setAttributeNS","setAttribute","removeAttribute","removeElement","parent","removeChild","removeChildren","call","patchElement","oldNode","newElement","createElement","toString","document","createTextNode","createElementNS","appendChild","insertBefore","nodeValue","oldProps","mounted","oldKeyed","newKeyed","oldElements","oldChildren","oldKey","k","newKey","keyedNode","rAF","window","requestAnimationFrame","cb","setTimeout","isObject","obj","Array","isArray","dataStore","Date","getTime","Component","selector","container","render","state","this","querySelector","componentShouldUpdate","componentWillMount","componentDidMount","componentWillUpdate","componentDidUpdate","componentWillUnmount","data","__data","vdom","elem","id","parentNode","__oldNode","component","JSON","stringify","nodeType","error","map","removeEventListener","event","_this","undefined","update","unmount","_this2","HeroSearch","search","searchResults","blurSearchInput","onkeyup","e","onblur","class","href","hero","name","HeroDashboard","heroes","selectHeroes","slice","HeroList","deleteItem","addHero","htmlFor","onclick","data-id","title","HeroDetail","onHeroNameChange","resetName","saveName","for","placeholder","oninput","Router","w","isModule","routes","reference","oldReference","oldUrl","Route","path","keys","fns","params","pathToRegexp","sensitive","strict","RegExp","join","concat","replace","_","slash","format","capture","optional","regex","fn","c","splice","apply","m","exec","len","val","decodeURIComponent","router","addHandler","s","split","reload","p","navigate","remove","route","removeHandler","removeAll","options","silent","location","hash","addListener","noConflict","load","run","getHash","substring","hashChanged","match","addEventListener","attachEvent","removeListener","detachEvent","message","module","exports","default","activeComponent","bind","selectedHero","app","fetch","then","response","json","setState","position","findIndex","person","originalName","err","input","target","lastId","newHero","String","parseInt","dataset","filter"],"mappings":"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"}